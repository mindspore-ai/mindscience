# Copyright 2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================

"""plotting results"""
import numpy as np
import matplotlib.pyplot as plt
import scipy.io
from scipy import stats
from sciai.utils import print_log


def plot_prediction_with_noise(x_val_np, y_val_np, y_pred, figure_path):
    """Plot prediction with noise"""
    n_samples = y_pred.shape[1]
    for i in range(0, n_samples):
        plt.plot(x_val_np, y_pred[:, i:i + 1], 'k.', alpha=0.005)
    plt.plot(x_val_np, y_val_np, 'r*', alpha=0.2)

    plt.xticks(fontsize=13)
    plt.yticks(fontsize=13)
    plt.xlabel('$x$', fontsize=13)
    plt.ylabel('$u(x)$', fontsize=13)
    plt.savefig(f'{figure_path}/prediction_with_noise.png', dpi=600)
    plt.close()


def plot_two_sigma_region(*inputs):
    """Plot two sigma region"""
    x_bound, y_bound, x_val, y_val, y_pred, figure_path = inputs
    mu_pred = np.mean(y_pred, axis=1)
    sigma_pred = np.var(y_pred, axis=1)

    lower = mu_pred - 2.0 * np.sqrt(sigma_pred)
    upper = mu_pred + 2.0 * np.sqrt(sigma_pred)

    plt.figure(2, figsize=(7, 5))

    plt.plot(x_bound, y_bound, 'kx', markersize=4, label="Boundary points")
    plt.fill_between(x_val.flatten(), lower.flatten(), upper.flatten(),
                     facecolor='orange', alpha=0.5, label="Two std band")
    plt.plot(x_val, y_val, 'b-', label="Exact", linewidth=2)
    plt.plot(x_val, mu_pred, 'r--', label="Prediction Mean", linewidth=2)

    plt.xticks(fontsize=13)
    plt.yticks(fontsize=13)
    plt.xlabel('$x$', fontsize=13)
    plt.ylabel('$u(x)$', fontsize=13)
    plt.legend(loc='upper left', frameon=False, prop={'size': 10})
    plt.savefig(f'{figure_path}/two_sigma_region.png', dpi=600)
    plt.close()


def plot_probability_density_kernel_estimation(args, x_val, y_pred, pos):
    """Plot probability density kernel estimation"""
    if pos < 0 or pos >= 200:
        print_log(f"The value of pos should in range [0, 200), but get {pos}")
        return

    # Load the reference solution of the stochastic ODE generated by Monte Carlo
    data = scipy.io.loadmat(f'{args.load_data_path}/ODE2000.mat')
    exact = np.real(data['U']).T

    exact_col = exact[pos, :][:, None]
    pred_col = y_pred[pos, :][:, None]

    u_marginal_exact, kde_marginal_exact = _obtain_marginal(exact_col)
    u_marginal_pred, kde_marginal_pred = _obtain_marginal(pred_col)

    plt.figure(3, figsize=(6, 4.7))
    plt.xticks(fontsize=13)
    plt.yticks(fontsize=13)
    plt.hist(exact[pos, :], bins=50, density=True, alpha=0.6, color='blue')
    plt.hist(y_pred[pos, :], bins=50, density=True, alpha=0.6, color='red')
    plt.plot(u_marginal_exact, kde_marginal_exact, 'b-', label='Exact')
    plt.plot(u_marginal_pred, kde_marginal_pred, 'r-', label='Prediction')
    plt.xlabel(f'$u(x = {x_val[pos]})$', fontsize=13)
    plt.ylabel('$p(u)$', fontsize=13)
    plt.legend(loc='upper left', frameon=False, prop={'size': 13})
    plt.savefig(f'{args.figures_path}/ODE_x{pos}.png', dpi=600)
    plt.close()


def _obtain_marginal(data):
    u_min, u_max = data.min(), data.max()
    u_marginal = np.linspace(u_min, u_max, 100)[:, None]
    positions_marginal = u_marginal.flatten()
    values_marginal = data.flatten()
    gkde = stats.gaussian_kde(values_marginal)
    kde_marginal = gkde.evaluate(positions_marginal)
    return u_marginal, kde_marginal
